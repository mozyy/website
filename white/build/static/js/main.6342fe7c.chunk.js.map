{"version":3,"sources":["bootstrap.js","env.ts","utils/textEncoder.ts","utils/message.ts","utils/connection.ts","utils/rtc.ts","components/White.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["URLWs","websocket","encode","data","dataStr","JSON","stringify","TextEncoder","decode","arr","TextDecoder","parse","sendMessage","conn","msg","send","log","console","reportError","error","closeVideoCall","peerConnection","ontrack","onicecandidate","oniceconnectionstatechange","onsignalingstatechange","onicegatheringstatechange","onnegotiationneeded","getTransceivers","forEach","transceiver","stop","close","handleNegotiationNeededEvent","uid","target","Object","asyncToGenerator","regenerator_default","a","mark","_callee","offer","wrap","_context","prev","next","createOffer","sent","signalingState","abrupt","setLocalDescription","kind","value","sdp","localDescription","t0","handleTrackEvent","event","streams","myHostname","window","location","hostname","createPeerConnection","RTCPeerConnection","iceServers","urls","username","credential","candidate","handleICECandidateEvent","iceConnectionState","handleICEConnectionStateChangeEvent","iceGatheringState","handleICEGatheringStateChangeEvent","handleSignalingStateChangeEvent","log_error","warn","decodeMessage","e","arrayBuffer","then","Connection","_EventTarget","_this","options","arguments","length","undefined","channel","classCallCheck","this","possibleConstructorReturn","getPrototypeOf","call","userlist","connPeers","Map","dataChannels","handleVideoOfferMsg","_ref","connPeer","desc","response","get","handleCreatePeerConn","RTCSessionDescription","Promise","all","type","setRemoteDescription","catch","createAnswer","t1","_x","_x2","apply","inherits","createClass","key","_init","_callee2","_context2","resolve","reject","connection","WebSocket","addEventListener","addListener","join","_this2","joinChannel","joinMessage","_ref2","_callee3","message","_context3","dispatchEvent","CustomEvent","detail","removeEventListener","_x3","dataChannel","err","_this3","_ref3","_callee4","peerConn","_context4","handleCreateDataChannel","handleVideoAnswerMsg","handleNewICECandidateMsg","handleHangUpMsg","_x4","_handleVideoAnswerMsg","_callee5","_context5","_x5","_x6","_handleNewICECandidateMsg","_callee6","_context6","RTCIceCandidate","addIceCandidate","_x7","_x8","_this4","set","handleCreateDataChanneled","Number","label","createDataChannel","String","_this5","logCurrentState","readyState","eventMessage","wrapNativeSuper","EventTarget","connect","_ref4","_callee7","_args7","_context7","init","useStyles","makeStyles","theme","root","width","height","display","touchAction","speedDial","position","bottom","spacing","right","event2Point","point","x","y","changedTouches","clientX","clientY","drawing","White","props","classes","cvsRef","useRef","colorRef","_useState","useState","_useState2","slicedToArray","dialOpen","setDialOpen","drawsRef","colorInputRef","connRef","setCurrentPoint","p","rect","current","getBoundingClientRect","Math","round","left","top","points","push","ctx","draw","strokeStyle","color","lineWidth","beginPath","moveTo","line","lineTo","stroke","drawLineHandler","getContext","sendPointMsg","_objectSpread","dataChannelsSend","drawLine","startHandler","moveHandler","stopHandler","moveHandlerThrottle","throttle","start","move","stopPropagation","actions","icon","react_default","createElement","Save_default","name","InvertColors_default","hanler","click","useEffect","datachannelmessage","dataMsg","decodeMsg","handleClose","className","ref","onMouseDown","onMouseMove","onMouseUp","onTouchStart","onTouchMove","onTouchEnd","SpeedDial","ariaLabel","SpeedDialIcon","onClick","o","onBlur","onClose","onFocus","onMouseEnter","onMouseLeave","open","map","action","SpeedDialAction","tooltipTitle","hidden","onChange","colorValue","App","Fragment","CssBaseline","components_White","isLocalhost","Boolean","match","registerValidSW","swUrl","config","navigator","serviceWorker","register","registration","onupdatefound","installingWorker","installing","onstatechange","state","controller","onUpdate","onSuccess","ReactDOM","render","src_App_0","document","getElementById","URL","process","href","origin","concat","fetch","contentType","headers","status","indexOf","ready","unregister","reload","checkValidServiceWorker"],"mappings":"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","file":"static/js/main.6342fe7c.chunk.js","sourcesContent":["\r\nif (process.env.NODE_ENV === 'development' && navigator.userAgent.match (/ Android/i)) {\r\n  import('vconsole').then(module=> new module.default())\r\n}\r\n\r\n// fix react typesript isolatedMoudles is true\r\nexport const noop = () => {}","import config from 'config/config.json'\r\n\r\ndeclare var process : {\r\n  env :{\r\n    NODE_ENV: 'development' | 'production'\r\n  }\r\n}\r\n\r\ninterface ConfigEnv {\r\n  websocket: string,\r\n}\r\n\r\nexport const configEnv: ConfigEnv = config[process.env.NODE_ENV]\r\n\r\n\r\nexport const URLWs = configEnv.websocket","import {Message} from './message'\r\n\r\n\r\nconst encoding = 'utf-8';\r\n\r\nexport const encode = (data: Message) => {\r\n  const dataStr = JSON.stringify(data);\r\n  return new TextEncoder().encode(dataStr);\r\n}\r\n\r\nexport const decode = (arr: Uint8Array): Message => {\r\n  const dataStr = new TextDecoder().decode(arr)\r\n  return JSON.parse(dataStr)\r\n}","\r\nimport { encode } from './textEncoder'\r\n\r\ntype requestKinds = 'join' | 'leave' | 'video-offer' | 'new-ice-candidate' | string // TODO: add every kinds\r\ntype responseKinds = 'join-success'|'join-failure'\r\n\r\nexport interface Message {\r\n  kind: requestKinds | responseKinds;\r\n  uid: number,\r\n  target?: number,\r\n  value: any\r\n}\r\n\r\nexport const sendMessage = (conn: WebSocket, msg: Message) => {\r\n  conn.send(encode(msg))\r\n}","import { sendMessage, Message } from './message'\r\n\r\n// Called by the WebRTC layer to let us know when it's time to\r\n// begin, resume, or restart ICE negotiation.\r\nconst log = console.log\r\nconst reportError = console.error\r\n\r\nexport const closeVideoCall = (peerConnection: RTCPeerConnection) => {\r\n\r\n  log(\"Closing the call\");\r\n\r\n  // Close the RTCPeerConnection\r\n\r\n  if (peerConnection) {\r\n    log(\"--> Closing the peer connection\");\r\n\r\n    // Disconnect all our event listeners; we don't want stray events\r\n    // to interfere with the hangup while it's ongoing.\r\n\r\n    peerConnection.ontrack = null;\r\n    peerConnection.onicecandidate = null;\r\n    peerConnection.oniceconnectionstatechange = null;\r\n    peerConnection.onsignalingstatechange = null;\r\n    peerConnection.onicegatheringstatechange = null;\r\n    peerConnection.onnegotiationneeded = null;\r\n\r\n    // Stop all transceivers on the connection\r\n\r\n    peerConnection.getTransceivers().forEach(transceiver => {\r\n      transceiver.stop();\r\n    });\r\n\r\n    // Stop the webcam preview as well by pausing the <video>\r\n    // element, then stopping each of the getUserMedia() tracks\r\n    // on it.\r\n\r\n    // if (localVideo.srcObject) {\r\n    //   localVideo.pause();\r\n    //   (localVideo.srcObject as MediaStream ).getTracks().forEach(track => {\r\n    //     track.stop();\r\n    //   });\r\n    // }\r\n\r\n    // Close the peer connection\r\n\r\n    peerConnection.close();\r\n  }\r\n\r\n}\r\n\r\nexport const handleNegotiationNeededEvent = (peerConnection: RTCPeerConnection, conn: WebSocket, uid: number, target: number) => async () => {\r\n  log(\"*** Negotiation needed\");\r\n\r\n  try {\r\n    log(\"---> Creating offer\");\r\n    const offer = await peerConnection.createOffer();\r\n\r\n    // If the connection hasn't yet achieved the \"stable\" state,\r\n    // return to the caller. Another negotiationneeded event\r\n    // will be fired when the state stabilizes.\r\n\r\n    if (peerConnection.signalingState != \"stable\") {\r\n      log(\"     -- The connection isn't stable yet; postponing...\")\r\n      return;\r\n    }\r\n\r\n    // Establish the offer as the local peer's current\r\n    // description.\r\n\r\n    log(\"---> Setting local description to the offer\");\r\n    await peerConnection.setLocalDescription(offer);\r\n\r\n    // Send the offer to the remote peer.\r\n\r\n    log(\"---> Sending the offer to the remote peer\");\r\n\r\n    const msg: Message = {\r\n      kind: 'video-offer',\r\n      uid,\r\n      target,\r\n      value: {\r\n        sdp: peerConnection.localDescription\r\n      }\r\n    }\r\n    sendMessage(conn, msg)\r\n    // sendToServer({\r\n    //   name: myUsername,\r\n    //   target: targetUsername,\r\n    //   type: \"video-offer\",\r\n    //   sdp: peerConnection.localDescription\r\n    // });\r\n  } catch(err) {\r\n    log(\"*** The following error occurred while handling the negotiationneeded event:\");\r\n    reportError(err);\r\n  };\r\n}\r\n\r\n// Called by the WebRTC layer when events occur on the media tracks\r\n// on our WebRTC call. This includes when streams are added to and\r\n// removed from the call.\r\n//\r\n// track events include the following fields:\r\n//\r\n// RTCRtpReceiver       receiver\r\n// MediaStreamTrack     track\r\n// MediaStream[]        streams\r\n// RTCRtpTransceiver    transceiver\r\n//\r\n// In our case, we're just taking the first stream found and attaching\r\n// it to the <video> element for incoming media.\r\n\r\nconst handleTrackEvent = (event: RTCTrackEvent) => {\r\n  log(\"*** Track event\", event.streams[0]);\r\n  // document.getElementById(\"received_video\").srcObject = event.streams[0];\r\n  // document.getElementById(\"hangup-button\").disabled = false;\r\n}\r\n\r\n// Handles |icecandidate| events by forwarding the specified\r\n// ICE candidate (created by our local ICE agent) to the other\r\n// peer through the signaling server.\r\n\r\nconst handleICECandidateEvent = (conn: WebSocket, uid: number, target: number) => (event: RTCPeerConnectionIceEvent) => {\r\n  if (event.candidate) {\r\n    log(\"*** Outgoing ICE candidate: \" + event.candidate.candidate);\r\n\r\n\r\n    const msg: Message = {\r\n      kind: 'new-ice-candidate',\r\n      uid,\r\n      target,\r\n      value: {\r\n        candidate: event.candidate\r\n      }\r\n    }\r\n    sendMessage(conn, msg)\r\n    // sendToServer({\r\n    //   type: \"new-ice-candidate\",\r\n    //   target: targetUsername,\r\n    //   candidate: event.candidate\r\n    // });\r\n  }\r\n}\r\n\r\n// Handle |iceconnectionstatechange| events. This will detect\r\n// when the ICE connection is closed, failed, or disconnected.\r\n//\r\n// This is called when the state of the ICE agent changes.\r\n\r\nconst handleICEConnectionStateChangeEvent = (peerConnection: RTCPeerConnection) => (event: Event) => {\r\n  log(\"*** ICE connection state changed to \" + peerConnection.iceConnectionState);\r\n\r\n  switch(peerConnection.iceConnectionState) {\r\n    case \"closed\":\r\n    case \"failed\":\r\n    case \"disconnected\":\r\n      closeVideoCall(peerConnection);\r\n      break;\r\n  }\r\n}\r\n\r\n// Set up a |signalingstatechange| event handler. This will detect when\r\n// the signaling connection is closed.\r\n//\r\n// NOTE: This will actually move to the new RTCPeerConnectionState enum\r\n// returned in the property RTCPeerConnection.connectionState when\r\n// browsers catch up with the latest version of the specification!\r\n\r\nconst handleSignalingStateChangeEvent = (peerConnection: RTCPeerConnection) => (event: Event) => {\r\n  log(\"*** WebRTC signaling state changed to: \" + peerConnection.signalingState);\r\n  switch(peerConnection.signalingState) {\r\n    case \"closed\":\r\n      closeVideoCall(peerConnection);\r\n      break;\r\n  }\r\n}\r\n\r\n// Handle the |icegatheringstatechange| event. This lets us know what the\r\n// ICE engine is currently working on: \"new\" means no networking has happened\r\n// yet, \"gathering\" means the ICE engine is currently gathering candidates,\r\n// and \"complete\" means gathering is complete. Note that the engine can\r\n// alternate between \"gathering\" and \"complete\" repeatedly as needs and\r\n// circumstances change.\r\n//\r\n// We don't need to do anything when this happens, but we log it to the\r\n// console so you can see what's going on when playing with the sample.\r\n\r\nconst handleICEGatheringStateChangeEvent = (peerConnection: RTCPeerConnection) => (event: Event) => {\r\n  log(\"*** ICE gathering state changed to: \" + peerConnection.iceGatheringState);\r\n}\r\n\r\n\r\nconst myHostname = window.location.hostname;\r\n\r\n\r\n\r\nexport const createPeerConnection = (conn: WebSocket, uid: number, target: number) => {\r\n\r\n  // Create an RTCPeerConnection which knows to use our chosen\r\n  // STUN server.\r\n\r\n  const peerConnection = new RTCPeerConnection({\r\n    iceServers: [     // Information about ICE servers - Use your own!\r\n      {\r\n        urls: \"turn:\" + myHostname,  // A TURN server\r\n        username: \"webrtc\",\r\n        credential: \"turnserver\"\r\n      }\r\n    ]\r\n  });\r\n\r\n  // Set up event handlers for the ICE negotiation process.\r\n\r\n  peerConnection.onicecandidate = handleICECandidateEvent(conn, uid, target);\r\n  peerConnection.oniceconnectionstatechange = handleICEConnectionStateChangeEvent(peerConnection);\r\n  peerConnection.onicegatheringstatechange = handleICEGatheringStateChangeEvent(peerConnection);\r\n  peerConnection.onsignalingstatechange = handleSignalingStateChangeEvent(peerConnection);\r\n  // peerConnection.onnegotiationneeded = handleNegotiationNeededEvent(peerConnection, conn, uid, target);\r\n  peerConnection.ontrack = handleTrackEvent;\r\n\r\n  return peerConnection\r\n}","import { URLWs } from '../env'\r\nimport { encode, decode } from './textEncoder'\r\nimport { Message, sendMessage } from './message'\r\nimport { createPeerConnection, closeVideoCall, handleNegotiationNeededEvent } from './connection'\r\n\r\nconst log = console.log\r\nconst log_error = console.warn\r\n\r\n\r\n\r\nexport const createSocket = () => new Promise<WebSocket>((resolve, reject) => {\r\n\r\n  const connection = new WebSocket(URLWs)\r\n\r\n  connection.addEventListener('open', (e)=>{\r\n    resolve(connection)\r\n  })\r\n  connection.addEventListener('error', (e)=>{\r\n    reject(e)\r\n  })\r\n})\r\n\r\ninterface Options {\r\n  channel: string,\r\n  uid?: number\r\n}\r\n\r\nconst decodeMessage = (e: MessageEvent): Promise<Message> => e.data.arrayBuffer().then(decode)\r\n\r\nexport class Connection extends EventTarget {\r\n  options :Options\r\n  conn: undefined | WebSocket\r\n  userlist = []\r\n  connPeers = new Map<number,RTCPeerConnection>()\r\n  dataChannels = new Map<number,RTCDataChannel>()\r\n  uid = 0\r\n  constructor (options:Options = {channel:'testChannel'}) {\r\n    super();\r\n    this.options = options\r\n  }\r\n  async init() {\r\n    this.conn = await createSocket()\r\n    this.addListener()\r\n    await this.join()\r\n  }\r\n  join() {\r\n    const joinChannel: Message = {\r\n      kind: 'join',\r\n      uid: this.uid,\r\n      value: {\r\n        channel: this.options.channel\r\n      }\r\n    };\r\n    const conn = this.conn as WebSocket\r\n  \r\n    conn.send(encode(joinChannel))\r\n    return new Promise<Message>((resolve, reject) => {\r\n      const joinMessage = async (e: MessageEvent): Promise<Message> => {\r\n        const message = await decodeMessage(e)\r\n        switch (message.kind) {\r\n          case 'join-success':\r\n            this.dispatchEvent(new CustomEvent('join-success', {detail: message.value}))\r\n            conn.removeEventListener('message', joinMessage)\r\n            resolve(message)\r\n          case 'join-failure':\r\n            this.dispatchEvent(new CustomEvent('join-failure', {detail: message.value}))\r\n            conn.removeEventListener('message', joinMessage)\r\n            reject('join-failure')\r\n          default:\r\n            return message\r\n        }\r\n      }\r\n      conn.addEventListener('message', joinMessage)\r\n    })\r\n  }\r\n\r\n  createPeerConnection(target: number) {\r\n    return createPeerConnection.call(this, this.conn as WebSocket, this.uid, target)\r\n  }\r\n\r\n  dataChannelsSend(msg: Message) {\r\n    const data = encode(msg)\r\n    this.dataChannels.forEach( dataChannel => {\r\n      try{\r\n        dataChannel.send(data)\r\n      }catch(err) {\r\n        console.log('send data channel message failed: ', err)\r\n      }\r\n    })\r\n  }\r\n\r\n  addListener() {\r\n    const conn = this.conn as WebSocket\r\n    conn.addEventListener('close', (e)=>{\r\n      console.log(e)\r\n      this.dispatchEvent(e)\r\n    })\r\n    conn.addEventListener('message', async (e)=>{\r\n      const msg = await decodeMessage(e)\r\n      console.log('message: ', msg)\r\n      this.dispatchEvent(e)\r\n      const {kind, value, uid, target} = msg\r\n      switch (kind) {\r\n        case 'join-success':\r\n          this.uid = target as number\r\n          break\r\n        case \"userlist\":      // Received an updated user list\r\n          this.userlist = value\r\n          break;\r\n        case \"user-joined\":\r\n          const peerConn = this.handleCreatePeerConn(uid)\r\n          handleNegotiationNeededEvent(peerConn, this.conn as WebSocket, this.uid, uid)()\r\n          this.handleCreateDataChannel(uid)\r\n          break\r\n  \r\n      // Signaling messages: these messages are used to trade WebRTC\r\n      // signaling information during negotiations leading up to a video\r\n      // call.\r\n  \r\n      case \"video-offer\":  // Invitation and offer to chat\r\n        this.handleVideoOfferMsg(uid, value);\r\n        break;\r\n  \r\n      case \"video-answer\":  // Callee has answered our offer\r\n        this.handleVideoAnswerMsg(uid, value);\r\n        break;\r\n  \r\n      case \"new-ice-candidate\": // A new ICE candidate has been received\r\n        this.handleNewICECandidateMsg(uid, value);\r\n        break;\r\n  \r\n      case \"hang-up\": // The other peer has hung up the call\r\n        this.handleHangUpMsg(uid, value);\r\n        break;\r\n  \r\n      // Unknown message; output to console for debugging.\r\n  \r\n      default:\r\n        log_error(\"Unknown message received:\");\r\n        log_error(msg);\r\n      }\r\n    })\r\n  }\r\n\r\n  handleVideoOfferMsg = async (target: number, msg: any) => {\r\n    let connPeer = this.connPeers.get(target) as RTCPeerConnection\r\n    // If we're not already connected, create an RTCPeerConnection\r\n    // to be linked to the caller.\r\n    if (connPeer == null) {\r\n      connPeer = this.handleCreatePeerConn(target)\r\n    }\r\n  \r\n    log(\"Received video chat offer from \" + target);\r\n  \r\n  \r\n    // We need to set the remote description to the received SDP offer\r\n    // so that our local WebRTC layer knows how to talk to the caller.\r\n  \r\n    var desc = new RTCSessionDescription(msg.sdp);\r\n  \r\n    // If the connection isn't stable yet, wait for it...\r\n  \r\n    if (connPeer.signalingState != \"stable\") {\r\n      log(\"  - But the signaling state isn't stable, so triggering rollback\");\r\n  \r\n      // Set the local and remove descriptions for rollback; don't proceed\r\n      // until both return.\r\n      await Promise.all([\r\n        connPeer.setLocalDescription({type: \"rollback\"}),\r\n        connPeer.setRemoteDescription(desc)\r\n      ]).catch(error => console.log('setLocalDescription: ', error));\r\n      return;\r\n    } else {\r\n      log (\"  - Setting remote description\");\r\n      await connPeer.setRemoteDescription(desc);\r\n    }\r\n  \r\n    // Get the webcam stream if we don't already have it\r\n  \r\n    // if (!webcamStream) {\r\n    //   try {\r\n    //     webcamStream = await navigator.mediaDevices.getUserMedia(mediaConstraints);\r\n    //   } catch(err) {\r\n    //     handleGetUserMediaError(err);\r\n    //     return;\r\n    //   }\r\n  \r\n    //   document.getElementById(\"local_video\").srcObject = webcamStream;\r\n  \r\n    //   // Add the camera stream to the RTCPeerConnection\r\n  \r\n    //   try {\r\n    //     webcamStream.getTracks().forEach(\r\n    //       transceiver = track => connPeer.addTransceiver(track, {streams: [webcamStream]})\r\n    //     );\r\n    //   } catch(err) {\r\n    //     handleGetUserMediaError(err);\r\n    //   }\r\n    // }\r\n  \r\n    log(\"---> Creating and sending answer to caller\");\r\n  \r\n    await connPeer.setLocalDescription(await connPeer.createAnswer());\r\n    const response = {\r\n      kind: 'video-answer',\r\n      uid: this.uid,\r\n      target,\r\n      value: {\r\n        sdp: connPeer.localDescription\r\n      }\r\n    }\r\n    sendMessage(this.conn as WebSocket, response)\r\n  \r\n    // sendToServer({\r\n    //   name: myUsername,\r\n    //   target: targetUsername,\r\n    //   type: \"video-answer\",\r\n    //   sdp: connPeer.localDescription\r\n    // });\r\n  }\r\n  async handleVideoAnswerMsg(target: number, msg: any) {\r\n    log(\"*** Call recipient has accepted our call\");\r\n  \r\n    // Configure the remote description, which is the SDP payload\r\n    // in our \"video-answer\" message.\r\n  \r\n    var desc = new RTCSessionDescription(msg.sdp);\r\n    await (this.connPeers.get(target) as RTCPeerConnection).setRemoteDescription(desc)\r\n  }\r\n\r\n  async handleNewICECandidateMsg(target: number, msg: any) {\r\n    var candidate = new RTCIceCandidate(msg.candidate);\r\n  \r\n    log(\"*** Adding received ICE candidate: \" + JSON.stringify(candidate));\r\n    await (this.connPeers.get(target) as RTCPeerConnection).addIceCandidate(candidate)\r\n  }\r\n  \r\n  handleHangUpMsg(target: number, msg: any) {\r\n    closeVideoCall(this.connPeers.get(target) as RTCPeerConnection)\r\n  }\r\n\r\n  handleCreatePeerConn(target: number) {\r\n    const connPeer = this.createPeerConnection(target)\r\n    this.connPeers.set(target,connPeer)\r\n    connPeer.addEventListener('datachannel', event => {\r\n      const dataChannel = event.channel\r\n     this.handleCreateDataChanneled(Number(dataChannel.label), dataChannel)\r\n    })\r\n    return connPeer\r\n  }\r\n\r\n  handleCreateDataChannel(target: number) {\r\n    const dataChannel = (this.connPeers.get(target) as RTCPeerConnection).createDataChannel(String(this.uid))\r\n    this.handleCreateDataChanneled(target, dataChannel)\r\n    return dataChannel\r\n  }\r\n\r\n  handleCreateDataChanneled(target: number, dataChannel: RTCDataChannel) {\r\n    const logCurrentState = () => {\r\n      console.log('current data channel state: ', dataChannel.readyState)\r\n    }\r\n    dataChannel.addEventListener('open', logCurrentState)\r\n    dataChannel.addEventListener('close', logCurrentState)\r\n    dataChannel.addEventListener('message', eventMessage => {\r\n      // this.dispatchEvent(eventMessage)\r\n      this.dispatchEvent(new CustomEvent('datachannelmessage', {detail: eventMessage}))\r\n    })\r\n    this.dataChannels.set(target,dataChannel)\r\n    return dataChannel\r\n  }\r\n\r\n  handleClose() {\r\n    if (this.conn) {\r\n      this.conn.close()\r\n    }\r\n    this.connPeers.forEach(connPeer => connPeer.close())\r\n    this.dataChannels.forEach(dataChannel => dataChannel.close())\r\n  }\r\n\r\n}\r\n\r\nexport const connect = async (options: Options = {channel:'testChannel'}) => {\r\n  const conn = new Connection()\r\n  \r\n  await conn.init()\r\n  return conn\r\n}","import React, {\r\n  useRef,\r\n  useCallback,\r\n  useState,\r\n  useEffect,\r\n  MouseEvent,\r\n  TouchEvent,\r\n  Touch\r\n} from \"react\";\r\nimport { makeStyles } from \"@material-ui/core/styles\";\r\nimport throttle from \"lodash/throttle\";\r\nimport SpeedDial from \"@material-ui/lab/SpeedDial\";\r\nimport SpeedDialIcon from \"@material-ui/lab/SpeedDialIcon\";\r\nimport SpeedDialAction from \"@material-ui/lab/SpeedDialAction\";\r\nimport InvertColors from \"@material-ui/icons/InvertColors\";\r\nimport SaveIcon from \"@material-ui/icons/Save\";\r\n\r\nimport { connect, Connection } from '../utils/rtc'\r\nimport { Message } from '../utils/message'\r\nimport { decode } from '../utils/textEncoder'\r\n\r\n// TODO: remove this\r\ndeclare global {\r\n  interface Window {\r\n    conn: any\r\n  }\r\n}\r\n\r\nconst canvasWidth = 1080 * 3;\r\nconst canvasHeight = 1080 * 3;\r\n\r\ninterface WhiteProps {}\r\n\r\n\r\nconst useStyles = makeStyles(theme => ({\r\n  root: {\r\n    width: \"100%\",\r\n    height: \"100vh\",\r\n    display: \"block\",\r\n    touchAction: \"none\"\r\n  },\r\n  speedDial: {\r\n    position: \"absolute\",\r\n    bottom: theme.spacing(2),\r\n    right: theme.spacing(3)\r\n  }\r\n}));\r\n\r\ninterface DrawPoint {\r\n  x: number;\r\n  y: number;\r\n}\r\n\r\ntype CtxStyle = string | CanvasGradient | CanvasPattern;\r\ninterface Draw {\r\n  color: CtxStyle;\r\n  points: DrawPoint[];\r\n}\r\ntype Draws = Draw[];\r\n\r\nconst event2Point = (event: MouseEvent | TouchEvent): DrawPoint => {\r\n  const point = {\r\n    x: 0,\r\n    y: 0\r\n  };\r\n  let value: Touch | MouseEvent;\r\n  switch (event.type) {\r\n    case \"touchstart\":\r\n    case \"touchmove\":\r\n    case \"touchend\":\r\n      value = (event as TouchEvent).changedTouches[0];\r\n      break;\r\n    case \"mousedown\":\r\n    case \"mousemove\":\r\n    case \"mouseup\":\r\n      value = event as MouseEvent;\r\n      break;\r\n    default:\r\n      value = event as MouseEvent;\r\n      break;\r\n  }\r\n\r\n  point.x = value.clientX;\r\n  point.y = value.clientY;\r\n  return point;\r\n};\r\nlet drawing = false;\r\nconst draw = (\r\n  startHandler: (p: DrawPoint) => void,\r\n  moveHandler: (p: DrawPoint) => void,\r\n  stopHandler: (p: DrawPoint) => void = ()=>{}\r\n) => {\r\n  const moveHandlerThrottle = throttle(moveHandler, 16);\r\n\r\n  const start = (event: MouseEvent | TouchEvent) => {\r\n    drawing = true;\r\n    startHandler(event2Point(event));\r\n  };\r\n  const move = (event: MouseEvent | TouchEvent) => {\r\n    if (drawing) {\r\n      event.stopPropagation();\r\n      moveHandlerThrottle(event2Point(event));\r\n    }\r\n  };\r\n  const stop = (event: MouseEvent | TouchEvent) => {\r\n    drawing = false;\r\n    stopHandler(event2Point(event));\r\n  };\r\n  return { start, move, stop };\r\n};\r\n\r\nconst drawLineHandler = (ctx: CanvasRenderingContext2D, draw: Draw) => {\r\n  ctx.strokeStyle = draw.color;\r\n  ctx.lineWidth = 15;\r\n  ctx.beginPath();\r\n  ctx.moveTo(draw.points[0].x, draw.points[0].y);\r\n  draw.points.forEach(line => {\r\n    ctx.lineTo(line.x, line.y);\r\n  });\r\n  ctx.stroke();\r\n};\r\n\r\nconst White: React.FC<WhiteProps> = props => {\r\n  const classes = useStyles();\r\n  console.log(\"run function components\");\r\n\r\n  const cvsRef = useRef<HTMLCanvasElement >(null)\r\n  const colorRef = useRef<CtxStyle>(\"\");\r\n  const [dialOpen, setDialOpen] = useState<boolean>(false);\r\n  const drawsRef = useRef<Draws>([]);\r\n  const colorInputRef = useRef<HTMLInputElement>(null);\r\n  const connRef = useRef<Connection>()\r\n\r\n\r\n  // useEffect(() => {\r\n  //   console.log('useEffect')\r\n  //   const ctx = ctxRef.current as CanvasRenderingContext2D;\r\n  //   ctx.clearRect(0,0,canvasWidth, canvasHeight)\r\n  //   drawsRef.current.forEach(drawHandler)\r\n  // });\r\n\r\n  const setCurrentPoint = (p: DrawPoint) => {\r\n    const rect = (cvsRef.current as HTMLCanvasElement).getBoundingClientRect()\r\n    const current = drawsRef.current[drawsRef.current.length - 1];\r\n    const point: DrawPoint = {\r\n      x: Math.round(((p.x - rect.left) * canvasWidth) / rect.width),\r\n      y: Math.round(((p.y - rect.top) * canvasHeight) / rect.height)\r\n    };\r\n    current.points.push(point);\r\n    const ctx = (cvsRef.current as HTMLCanvasElement).getContext(\"2d\") as CanvasRenderingContext2D;\r\n    drawLineHandler(ctx, current);\r\n  };\r\n\r\n  const sendPointMsg = (data: any) => {\r\n    const conn = connRef.current\r\n    if(conn) {\r\n      const msg = {\r\n        ...data,\r\n        uid: conn.uid,\r\n       }\r\n      conn.dataChannelsSend(msg)\r\n    }\r\n  }\r\n\r\n  const drawLine = draw(\r\n    point => {\r\n      drawsRef.current.push({ color: colorRef.current, points: [] });\r\n      setCurrentPoint(point);\r\n      sendPointMsg({kind: 'pointStart', value: point})\r\n    },\r\n    point => {\r\n      setCurrentPoint(point);\r\n      sendPointMsg({kind: 'pointMove', value: point})\r\n    }\r\n  );\r\n\r\n  const colorChange = (event: React.ChangeEvent<HTMLInputElement>) => {\r\n    const colorValue = event.target.value\r\n    colorRef.current = colorValue\r\n    sendPointMsg({kind: 'colorChange', value: colorValue})\r\n  }\r\n\r\n  const actions = [\r\n    { icon: <SaveIcon />, name: \"Save\" },\r\n    // { icon: <PrintIcon />, name: \"Print\" },\r\n    // { icon: <ShareIcon />, name: \"Share\" },\r\n    // { icon: <DeleteIcon />, name: \"Delete\" },\r\n    {\r\n      icon: <InvertColors />, \r\n      name: \"color\",\r\n      hanler() {\r\n        (colorInputRef.current as HTMLInputElement).click()\r\n        setDialOpen(false)\r\n      }\r\n    }\r\n  ];\r\n\r\n  // web rtc\r\n  useEffect(()=>{\r\n    const datachannelmessage = (event: Event) => {\r\n      const dataMsg = ((event as CustomEvent).detail as MessageEvent)\r\n      const decodeMsg = decode(dataMsg.data as Uint8Array)\r\n      console.log(decodeMsg)\r\n      switch(decodeMsg.kind) {\r\n        case 'pointStart':\r\n          drawsRef.current.push({ color: colorRef.current, points: [] });\r\n          setCurrentPoint(decodeMsg.value);\r\n          break;\r\n        case 'pointMove':\r\n          setCurrentPoint(decodeMsg.value);\r\n          break;\r\n        case 'colorChange':\r\n          colorRef.current = decodeMsg.value\r\n          break;\r\n      }\r\n    }\r\n    const init = async () => {\r\n      const conn = await connect();\r\n      (window.conn as any) = connRef.current = conn // TODO: remove this\r\n      conn.addEventListener('datachannelmessage', datachannelmessage)\r\n    }\r\n    init()\r\n    return () => {\r\n      const conn = connRef.current\r\n      if (conn) {\r\n        conn.removeEventListener('datachannelmessage', datachannelmessage)\r\n        conn.handleClose()\r\n      }\r\n    }\r\n  },[])\r\n\r\n  return (\r\n    <div>\r\n      <canvas\r\n        className={classes.root}\r\n        ref={cvsRef}\r\n        height={canvasHeight}\r\n        width={canvasWidth}\r\n        onMouseDown={drawLine.start}\r\n        onMouseMove={drawLine.move}\r\n        onMouseUp={drawLine.stop}\r\n        onTouchStart={drawLine.start}\r\n        onTouchMove={drawLine.move}\r\n        onTouchEnd={drawLine.stop}\r\n        // onPointerDown={drawLine.start}\r\n        // onPointerMove={drawLine.move}\r\n        // onPointerUp={drawLine.stop}\r\n      />\r\n      <SpeedDial\r\n        ariaLabel=\"SpeedDial\"\r\n        className={classes.speedDial}\r\n        // hidden={dialOpen}\r\n        icon={<SpeedDialIcon />}\r\n        onClick={() => setDialOpen(o=>!o)}\r\n        onBlur={() => setDialOpen(false)}\r\n        onClose={() => setDialOpen(false)}\r\n        onFocus={() => setDialOpen(true)}\r\n        onMouseEnter={() => setDialOpen(true)}\r\n        onMouseLeave={() => setDialOpen(false)}\r\n        open={dialOpen}\r\n        // direction={direction}\r\n      >\r\n        {actions.map(action => (\r\n          <SpeedDialAction\r\n            key={action.name}\r\n            icon={action.icon}\r\n            tooltipTitle={action.name}\r\n            onClick={action.hanler || console.log}\r\n          />\r\n        ))}\r\n      </SpeedDial>\r\n      <input\r\n        ref={colorInputRef}\r\n        type=\"color\"\r\n        hidden\r\n        onChange={colorChange}\r\n      />\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default White;\r\n","import React from 'react';\nimport CssBaseline from '@material-ui/core/CssBaseline';\n// import 'normalize.css';\nimport './App.css';\nimport White from './components/White';\n\nconst App: React.FC = () => {\n  return (\n    <React.Fragment>\n      <CssBaseline />\n      <div className=\"App\">\n        <White />\n      </div>\n    </React.Fragment>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import './bootstrap';\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n\nconst serviceConfig = {\n  onSuccess: (registration: ServiceWorkerRegistration)=> {\n    console.log('onSuccess', registration)\n  },\n  onUpdate: (registration: ServiceWorkerRegistration) => {\n    console.log('onUpdate', registration)\n  }\n}\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.register(serviceConfig);\n// serviceWorker.unregister();\n// navigator.serviceWorker.ready.then(registration=> {\n//   // registration.addEventListener()\n//   console.log(registration)\n// })"],"sourceRoot":""}