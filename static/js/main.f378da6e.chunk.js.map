{"version":3,"sources":["components/White.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["useStyles","makeStyles","root","width","height","display","touchAction","event2Point","event","value","point","x","y","type","targetTouches","changedTouches","clientX","clientY","drawing","drawLineHandler","ctx","draw","strokeStyle","style","lineWidth","beginPath","points","forEach","line","index","moveTo","lineTo","stroke","White","props","startHandler","moveHandler","stopHandler","classes","_useCanvasCtx","_useState","useState","_useState2","Object","slicedToArray","rect","setRect","ctxRef","useRef","useCallback","canvas","getBoundingClientRect","current","getContext","useCanvasCtx","_useCanvasCtx2","ref","draws","setCurrentPoint","concat","toConsumableArray","drawHandler","moveHandlerThrottle","throttle","drawLine","d","Math","round","start","move","stopPropagation","stop","react_default","a","createElement","className","onMouseDown","onMouseMove","onMouseUp","onTouchStart","onTouchMove","onTouchEnd","App","Fragment","CssBaseline","components_White","isLocalhost","Boolean","window","location","hostname","match","registerValidSW","swUrl","config","navigator","serviceWorker","register","then","registration","onupdatefound","installingWorker","installing","onstatechange","state","controller","console","log","onUpdate","onSuccess","catch","error","ReactDOM","render","src_App_0","document","getElementById","URL","process","href","origin","addEventListener","fetch","response","contentType","headers","get","status","indexOf","ready","unregister","reload","checkValidServiceWorker"],"mappings":"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","file":"static/js/main.f378da6e.chunk.js","sourcesContent":["import React, { useRef, useCallback, useState, useEffect, MouseEvent, TouchEvent, Touch } from \"react\";\r\nimport { makeStyles } from '@material-ui/styles'\r\nimport throttle from 'lodash/throttle'\r\n\r\n\r\nconst canvasWidth = 1920 * 3\r\nconst canvasHeight = 1080 * 3\r\n\r\ninterface WhiteProps {\r\n}\r\n\r\nconst useCanvasCtx = ():[(canvas: HTMLCanvasElement) => void, React.MutableRefObject<CanvasRenderingContext2D | null>, ClientRect] => {\r\n  const [rect, setRect] = useState<ClientRect|null>(null);\r\n  const ctxRef = useRef<CanvasRenderingContext2D | null>(null)\r\n  const ref = useCallback((canvas: HTMLCanvasElement)=>{\r\n    setRect(canvas.getBoundingClientRect());\r\n    ctxRef.current = canvas.getContext('2d')\r\n  },[])\r\n  return [ref, ctxRef, rect as ClientRect]\r\n}\r\n\r\nconst useStyles = makeStyles({\r\n  root: {\r\n    width: '100%',\r\n    height: '100vh',\r\n    display: 'block',\r\n    touchAction: 'none',\r\n  }\r\n})\r\n\r\ninterface DrawPoint {\r\n  x: number,\r\n  y: number,\r\n}\r\ninterface Draw {\r\n  style: string | CanvasGradient | CanvasPattern,\r\n  points: DrawPoint[]\r\n}\r\ntype Draws = Draw[]\r\n\r\nconst event2Point = (event: MouseEvent|TouchEvent):DrawPoint => {\r\n  const point = {\r\n    x: 0,\r\n    y: 0,\r\n  }\r\n  let value: Touch|MouseEvent;\r\n  switch(event.type) {\r\n    case 'touchstart':\r\n    case 'touchmove':\r\n      value = (event as TouchEvent).targetTouches[0]\r\n      break;\r\n    case 'touchend':\r\n      value = (event as TouchEvent).changedTouches[0]\r\n      break;\r\n    case 'mousedown':\r\n    case 'mousemove':\r\n    case 'mouseup':\r\n      value = (event as MouseEvent)\r\n      break;\r\n    default:\r\n      return point\r\n  }\r\n\r\n  point.x = value.clientX\r\n  point.y = value.clientY\r\n  return point\r\n}\r\nlet drawing = false;\r\nconst draw = (startHandler: (p: DrawPoint)=>void, moveHandler:(p: DrawPoint)=>void, stopHandler: (p: DrawPoint)=>void)=> {\r\n  const start = (event: MouseEvent|TouchEvent) => {\r\n    drawing = true;\r\n    startHandler(event2Point(event))\r\n  }\r\n  const move = (event: MouseEvent|TouchEvent) => {\r\n    if (drawing) {\r\n      event.stopPropagation()\r\n      moveHandler(event2Point(event))\r\n    }\r\n  }\r\n  const stop = (event: MouseEvent|TouchEvent) => {\r\n    drawing = false;\r\n    stopHandler(event2Point(event))\r\n  }\r\n  return { start, move, stop }\r\n}\r\n\r\nconst drawLineHandler = (ctx: CanvasRenderingContext2D, draw:Draw)=> {\r\n  ctx.strokeStyle = draw.style\r\n  ctx.lineWidth = 15\r\n  ctx.beginPath()\r\n  draw.points.forEach((line,index)=> {\r\n    if (index === 0 ) {\r\n      ctx.moveTo(line.x, line.y)\r\n      ctx.lineTo(line.x, line.y)\r\n    } else {\r\n      ctx.lineTo(line.x, line.y)\r\n    }\r\n  })\r\n  ctx.stroke()\r\n}\r\n\r\nconst White: React.FC<WhiteProps> = (props)=> {\r\n  const classes = useStyles()\r\n  const [ref, ctxRef, rect] = useCanvasCtx()\r\n  // const [draws, setDraws] = useState<Draws>([])\r\n  // const [currentDraw, setCurrentDraw] = useState<Draw>({style: 'red', points:[]})\r\n  const draws = useRef({draws: [] as Draws, current: {style: 'red', points: []} as Draw})\r\n\r\n  // useEffect(()=>{\r\n  //   const ctx = ctxRef.current as CanvasRenderingContext2D\r\n  //   ctx.clearRect(0,0, canvasWidth, canvasHeight)\r\n\r\n  //   draws.forEach(draw=>drawLineHandler(ctx, draw))\r\n  //   drawLineHandler(ctx, currentDraw)\r\n  // },[draws, currentDraw, ctxRef])\r\n\r\n  const drawHandler = () => {\r\n    const ctx = ctxRef.current as CanvasRenderingContext2D\r\n    draws.current.draws.forEach(draw => drawLineHandler(ctx, draw))\r\n    drawLineHandler(ctx, draws.current.current)\r\n  }\r\n  const setCurrentPoint = (point: DrawPoint) => {\r\n    const current = draws.current.current\r\n    draws.current.current = {\r\n      style: current.style,\r\n      points: [...current.points, point]\r\n    }\r\n    drawHandler()\r\n  }\r\n  const moveHandlerThrottle = throttle((point)=> setCurrentPoint(point), 16)\r\n   \r\n  const drawLine = draw((d)=>{\r\n    const point: DrawPoint = {\r\n      x: Math.round(d.x * canvasWidth  /rect.width),\r\n      y: Math.round(d.y * canvasHeight / rect.height)\r\n    }\r\n    // setCurrentDraw(d=>({\r\n    //   style:d.style,\r\n    //   points: [...d.points, point]\r\n    // }))\r\n    setCurrentPoint(point)\r\n  }, (d)=>{\r\n    const point: DrawPoint = {\r\n      x: d.x * canvasWidth  /rect.width,\r\n      y: d.y * canvasHeight / rect.height\r\n    }\r\n    // setCurrentDraw(d=>({\r\n    //   style:d.style,\r\n    //   points: [...d.points, point]\r\n    // }))\r\n    moveHandlerThrottle(point)\r\n  },()=>{\r\n    // setDraws(d=>[...d,currentDraw])\r\n    // setCurrentDraw({style: 'red', points:[]})\r\n  })\r\n\r\n\r\n  return (\r\n    <canvas \r\n      className={classes.root} \r\n      ref={ref}\r\n      height={canvasHeight} \r\n      width={canvasWidth} \r\n      onMouseDown={drawLine.start}\r\n      onMouseMove={drawLine.move}\r\n      onMouseUp={drawLine.stop}\r\n      onTouchStart={drawLine.start}\r\n      onTouchMove={drawLine.move}\r\n      onTouchEnd={drawLine.stop}\r\n    >\r\n      {/* <SpeedDial\r\n            ariaLabel=\"SpeedDial\"\r\n            className={speedDialClassName}\r\n            hidden={hidden}\r\n            icon={<SpeedDialIcon />}\r\n            onBlur={this.handleClose}\r\n            onClick={this.handleClick}\r\n            onClose={this.handleClose}\r\n            onFocus={this.handleOpen}\r\n            onMouseEnter={this.handleOpen}\r\n            onMouseLeave={this.handleClose}\r\n            open={open}\r\n            direction={direction}\r\n          >\r\n            {actions.map(action => (\r\n              <SpeedDialAction\r\n                key={action.name}\r\n                icon={action.icon}\r\n                tooltipTitle={action.name}\r\n                onClick={this.handleClick}\r\n              />\r\n            ))}\r\n          </SpeedDial> */}\r\n    </canvas>\r\n  )\r\n}\r\n\r\nexport default White","import React from 'react';\nimport CssBaseline from '@material-ui/core/CssBaseline';\n// import 'normalize.css';\nimport './App.css';\nimport White from './components/White';\n\nconst App: React.FC = () => {\n  return (\n    <React.Fragment>\n      <CssBaseline />\n      <div className=\"App\">\n        <White />\n      </div>\n    </React.Fragment>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n\nconst serviceConfig = {\n  onSuccess: (registration: ServiceWorkerRegistration)=> {\n    console.log('onSuccess', registration)\n  },\n  onUpdate: (registration: ServiceWorkerRegistration) => {\n    console.log('onUpdate', registration)\n  }\n}\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.register(serviceConfig);\n// navigator.serviceWorker.ready.then(registration=> {\n//   // registration.addEventListener()\n//   console.log(registration)\n// })"],"sourceRoot":""}