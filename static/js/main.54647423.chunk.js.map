{"version":3,"sources":["components/White.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["useStyles","makeStyles","root","width","height","display","event2Point","event","value","point","x","y","type","targetTouches","changedTouches","clientX","clientY","drawing","White","props","classes","_useState3","useState","_useState4","Object","slicedToArray","_useCanvasCtx","_useState","_useState2","rect","setRect","ctxRef","useRef","useCallback","canvas","getBoundingClientRect","current","getContext","useCanvasCtx","_useCanvasCtx2","ref","_useState5","_useState6","draws","setDraws","_useState7","style","points","_useState8","currentDraw","setCurrentDraw","useEffect","ctx","clearRect","drawLineHandler","draw","strokeStyle","lineWidth","beginPath","forEach","line","index","moveTo","lineTo","stroke","startHandler","moveHandler","stopHandler","drawLine","d","concat","toConsumableArray","console","log","start","move","stop","react_default","a","createElement","className","onMouseDown","onMouseMove","onMouseUp","onTouchStart","onTouchMove","onTouchEnd","App","Fragment","CssBaseline","components_White","isLocalhost","Boolean","window","location","hostname","match","registerValidSW","swUrl","config","navigator","serviceWorker","register","then","registration","onupdatefound","installingWorker","installing","onstatechange","state","controller","onUpdate","onSuccess","catch","error","ReactDOM","render","src_App_0","document","getElementById","URL","process","href","origin","addEventListener","fetch","response","contentType","headers","get","status","indexOf","ready","unregister","reload","checkValidServiceWorker"],"mappings":"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","file":"static/js/main.54647423.chunk.js","sourcesContent":["import React, { useRef, useCallback, useState, useEffect, MouseEvent, TouchEvent, Touch } from \"react\";\r\nimport { makeStyles } from '@material-ui/styles'\r\n\r\n\r\nconst canvasWidth = 1920 * 3\r\nconst canvasHeight = 1080 * 3\r\n\r\ninterface WhiteProps {\r\n}\r\n\r\nconst useCanvasCtx = ():[(canvas: HTMLCanvasElement) => void, React.MutableRefObject<CanvasRenderingContext2D | null>, ClientRect] => {\r\n  const [rect, setRect] = useState<ClientRect|null>(null);\r\n  const ctxRef = useRef<CanvasRenderingContext2D | null>(null)\r\n  const ref = useCallback((canvas: HTMLCanvasElement)=>{\r\n    setRect(canvas.getBoundingClientRect());\r\n    ctxRef.current = canvas.getContext('2d')\r\n  },[])\r\n  return [ref, ctxRef, rect as ClientRect]\r\n}\r\n\r\nconst useStyles = makeStyles({\r\n  root: {\r\n    width: '100%',\r\n    height: '100vh',\r\n    display: 'block',\r\n  }\r\n})\r\n\r\ninterface DrawPoint {\r\n  x: number,\r\n  y: number,\r\n}\r\ninterface Draw {\r\n  style: string | CanvasGradient | CanvasPattern,\r\n  points: DrawPoint[]\r\n}\r\ntype Draws = Draw[]\r\n\r\nconst event2Point = (event: MouseEvent|TouchEvent):DrawPoint => {\r\n  const point = {\r\n    x: 0,\r\n    y: 0,\r\n  }\r\n  let value: Touch|MouseEvent;\r\n  switch(event.type) {\r\n    case 'touchstart':\r\n    case 'touchmove':\r\n      value = (event as TouchEvent).targetTouches[0]\r\n      break;\r\n    case 'touchend':\r\n      value = (event as TouchEvent).changedTouches[0]\r\n      break;\r\n    case 'mousedown':\r\n    case 'mousemove':\r\n    case 'mouseup':\r\n      value = (event as MouseEvent)\r\n      break;\r\n    default:\r\n      return point\r\n  }\r\n\r\n  point.x = value.clientX\r\n  point.y = value.clientY\r\n  return point\r\n}\r\nlet drawing = false;\r\nconst draw = (startHandler: (p: DrawPoint)=>void, moveHandler:(p: DrawPoint)=>void, stopHandler: (p: DrawPoint)=>void)=> {\r\n  const start = (event: MouseEvent|TouchEvent) => {\r\n    drawing = true;\r\n    startHandler(event2Point(event))\r\n  }\r\n  const move = (event: MouseEvent|TouchEvent) => {\r\n    if (drawing) {\r\n      moveHandler(event2Point(event))\r\n    }\r\n  }\r\n  const stop = (event: MouseEvent|TouchEvent) => {\r\n    drawing = false;\r\n    stopHandler(event2Point(event))\r\n  }\r\n  return { start, move, stop }\r\n}\r\n\r\n\r\nconst White: React.FC<WhiteProps> = (props)=> {\r\n  const classes = useStyles()\r\n  const [height,setHeight] = useState(100)\r\n  const [ref, ctxRef, rect] = useCanvasCtx()\r\n  const [draws, setDraws] = useState<Draws>([])\r\n  const [currentDraw, setCurrentDraw] = useState<Draw>({style: 'red', points:[]})\r\n\r\n  useEffect(()=>{\r\n    const ctx = ctxRef.current as CanvasRenderingContext2D\r\n    ctx.clearRect(0,0, canvasWidth, canvasHeight)\r\n\r\n    const drawLineHandler = (draw:Draw)=> {\r\n      ctx.strokeStyle = draw.style\r\n      ctx.lineWidth = 15\r\n      ctx.beginPath()\r\n      draw.points.forEach((line,index)=> {\r\n        if (index === 0 ) {\r\n          ctx.moveTo(line.x, line.y)\r\n          ctx.lineTo(line.x, line.y)\r\n        } else {\r\n          ctx.lineTo(line.x, line.y)\r\n        }\r\n      })\r\n      ctx.stroke()\r\n    }\r\n    draws.forEach(drawLineHandler)\r\n    drawLineHandler(currentDraw)\r\n  },[draws, currentDraw])\r\n\r\n  const drawLine = draw((d)=>{\r\n    const point: DrawPoint = {\r\n      x: d.x * canvasWidth  /rect.width,\r\n      y: d.y * canvasHeight / rect.height\r\n    }\r\n    setCurrentDraw(d=>({\r\n      style:d.style,\r\n      points: [...d.points, point]\r\n    }))\r\n    console.log(rect)\r\n  }, (d)=>{\r\n    const point: DrawPoint = {\r\n      x: d.x * canvasWidth  /rect.width,\r\n      y: d.y * canvasHeight / rect.height\r\n    }\r\n    setCurrentDraw(d=>({\r\n      style:d.style,\r\n      points: [...d.points, point]\r\n    }))\r\n  },()=>{\r\n    setDraws(d=>[...d,currentDraw])\r\n    setCurrentDraw({style: 'red', points:[]})\r\n  })\r\n\r\n\r\n  return (\r\n    <canvas \r\n      className={classes.root} \r\n      ref={ref}\r\n      height={canvasHeight} \r\n      width={canvasWidth} \r\n      onMouseDown={drawLine.start}\r\n      onMouseMove={drawLine.move}\r\n      onMouseUp={drawLine.stop}\r\n      onTouchStart={drawLine.start}\r\n      onTouchMove={drawLine.move}\r\n      onTouchEnd={drawLine.stop}\r\n    >\r\n      {/* <SpeedDial\r\n            ariaLabel=\"SpeedDial\"\r\n            className={speedDialClassName}\r\n            hidden={hidden}\r\n            icon={<SpeedDialIcon />}\r\n            onBlur={this.handleClose}\r\n            onClick={this.handleClick}\r\n            onClose={this.handleClose}\r\n            onFocus={this.handleOpen}\r\n            onMouseEnter={this.handleOpen}\r\n            onMouseLeave={this.handleClose}\r\n            open={open}\r\n            direction={direction}\r\n          >\r\n            {actions.map(action => (\r\n              <SpeedDialAction\r\n                key={action.name}\r\n                icon={action.icon}\r\n                tooltipTitle={action.name}\r\n                onClick={this.handleClick}\r\n              />\r\n            ))}\r\n          </SpeedDial> */}\r\n    </canvas>\r\n  )\r\n}\r\n\r\nexport default White","import React from 'react';\nimport CssBaseline from '@material-ui/core/CssBaseline';\n// import 'normalize.css';\nimport './App.css';\nimport White from './components/White';\n\nconst App: React.FC = () => {\n  return (\n    <React.Fragment>\n      <CssBaseline />\n      <div className=\"App\">\n        <White />\n      </div>\n    </React.Fragment>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n\nconst serviceConfig = {\n  onSuccess: (registration: ServiceWorkerRegistration)=> {\n    console.log('onSuccess', registration)\n  },\n  onUpdate: (registration: ServiceWorkerRegistration) => {\n    console.log('onUpdate', registration)\n  }\n}\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.register(serviceConfig);\nnavigator.serviceWorker.ready.then(registration=> {\n  // registration.addEventListener()\n  console.log(registration)\n})"],"sourceRoot":""}